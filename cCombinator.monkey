Strict

Import cCombinatorics
Import iCombinatoricsGenerator
Import iCombinatorCallback
Import tCombinatoricsExceptions

' Generates combinations of elements from a given element pool. The number of elements
' in the pool must be less than 31. See NextValue() for a brief explanation.
Class Combinator<T> Implements ICombinatoricsGenerator<T>
	Private
	' Holds the elements this object was initialized with
	Field elements:T[]
	' The last value generated by NextValue()
	Field currentValue:T[]
	' An object containing code to be applied to each element retrieved
	' via NextValue() before that element is returned.
	Field nextValueFilter:ICombinatorCallback<T>
	' An internal pointer to track where in the generation series we currently are
	Field combinationBitPattern:Int
	' The position in the generator series of the last generated combination. This
	' number is 0-indexed, so the first generated combination is combination number
	' 0, not combination 1.
	Field currentSeriesPosition:Int
	' The maximum possible index
	Field maximumIndex:Int
	' The number of combinations/permutations in the generator's space
	Field length:Int
	' The combination group size this generator is configured for. We could shave 
	' microseconds by calculating and storing the initial combinationBitPattern
	' inside New(), but it is convenient to have this piece of information handy,
	' and we shouldn't be calling Reset() often enough for it to matter.
	Field groupSize:Int
	' For access to permutation and combination functions
	Field combinatorics:Combinatorics
	
	' Calculates a bit pattern that will be used by NextValue() to build
	' the next combination of elements.
	Method AdvancePointer:Void()
		Local leastSignificantBit:Int = combinationBitPattern & - combinationBitPattern
		Local wave:Int = combinationBitPattern + leastSignificantBit
		Local leastSignificantBitInWave:Int = wave & - wave
		Local additionalMask:Int = ( (leastSignificantBitInWave / leastSignificantBit) Shr 1) - 1
		combinationBitPattern = wave | additionalMask
		currentSeriesPosition += 1
	End Method

	' Sets the initial bit pattern which will be used to select elements
	' from the elements array to form a combination.
	Method Reset:Void()
		combinationBitPattern = (1 Shl groupSize) - 1
		currentSeriesPosition = -1
		currentValue = New T[groupSize]
	End Method
	
	Public
	' Initialize a new Combinator. Elements is an array of type T, and
	' groupSize is the number of elements to use in each combination.
	Method New()
		Throw New CombinatorConstructorArgumentsException()
	End Method
	
	Method New(_elements:T[], _groupSize:Int = 0)
		If (_elements.Length > 30)
			Throw New CombinatorElementsSizeException
		EndIf
		If (_groupSize < 0)
			Throw New CombinatorGroupSizeException()
		ElseIf(_groupSize = 0)
			_groupSize = _elements.Length
		ElseIf(_groupSize > _elements.Length)
			Throw New CombinatorGroupSizeException()
		EndIf

		groupSize = _groupSize
		elements = _elements
		length = Combinatorics.Choose(elements.Length, groupSize)
		maximumIndex = 1 Shl elements.Length
		Reset()
	End Method

	Method Length:Int()
		Return length
	End Method
	
	' Generates the next combination of elements, and returns it as
	' an array. Elements are selected from the elements array based
	' on the bits in combinationBitsPattern. For instance, a bit
	' pattern of ... 001111 would select the first four elements
	' from the array for use in the group. A bit pattern of
	' ... 00101011 would select the first, second, fourth, and
	' sixth elements from the elements array. This bit-fiddling
	' is why this generator can only work with element lists
	' containing less than thirty-one items.
	Method NextValue:T[] ()
		If (combinationBitPattern > maximumIndex)
			Local emptyResult:T[]
			Return emptyResult
		EndIf
		
		Local i:Int = 0
		Local j:Int = 0
		Local tmpIndex:Int = combinationBitPattern
		Local filterAvailable:Bool = (nextValueFilter <> Null)
		
		While (tmpIndex)
			If (tmpIndex & 1)
				If (filterAvailable)
					currentValue[j] = nextValueFilter.Execute(elements[i])
				Else
					currentValue[j] = elements[i]
				EndIf
				j += 1
			EndIf

			tmpIndex = tmpIndex Shr 1
			i += 1
		Wend

		AdvancePointer()
		
		Return currentValue[ ..]
	End Method
	
	Method GetValueAtIndex:T[] (index:Int)
		If (index < 0)
			
		EndIf
		Local _combinationBitPattern:Int = combinationBitPattern
		Local _currentValue:String[] = currentValue[ ..]
		Local _currentSeriesPosition:Int = currentSeriesPosition
		
		Reset()
		
		For Local i:Int = 0 Until index
			AdvancePointer()
		Next
		
		Local result:T[] = NextValue()
		
		combinationBitPattern = _combinationBitPattern
		currentValue = _currentValue
		currentSeriesPosition = _currentSeriesPosition
		
		Return result
	End Method
	
	Method ToArray:T[][] ()
		Local results:T[length][]

		Reset()
		
		For Local seriesIndex:Int = 0 To length - 1
			results[seriesIndex] = NextValue()
		Next

		Return results
	End Method

	Method SetNextValueFilter:Void(filter:ICombinatorCallback<T>)
		nextValueFilter = filter
	End Method
	
	Method ToStack:Stack<T[] > ()
		Local result:Stack<T[] > = New Stack<T[]>(ToArray())

		Return result
	End Method
	
	Method ToList:List<T[] > ()
		Local result:List<T[] > = New List<T[]>(ToArray())

		Return result
	End Method
	
	Method GetGetCurrentValue:T[] ()
		Return currentValue
	End Method
	
	Method GetCurrentSeriesPosition:Int()
		Return currentSeriesPosition
	End Method
End Class
